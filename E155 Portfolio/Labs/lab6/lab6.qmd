---
title: "Lab 6: The Internet of Things and Serial Peripheral Interface"

---

## Introduction
In this lab, the objective was to design and build a simple IoT device, write C libraries to implement SPI on the MCU and interface with a temperature sensor, interface with a ESP8266 module using UART, and write an HTML page to control an LED and temperature sensor. The webpage allows users to select the output resolution for the temperature sensor and displays the temperature sensor reading. When selecting a specific resolution on the webpage, the MCU would then send the specific write and read commands to the temperature sensor.


## MCU Design and Testing Methodology. 
The design was developed by using interrupts. Interrupts were used both from the signals from the encoders and the timer. 


The interrupt for the quad encoder signals would fire when the system recorded a signal from the B or A signal, where the design detected all edges of the encoder pulses to achieve high resolution. The current state on the encoder would update respectively. A lookup table was implemented in order to create the counter logic, indicating when the encoder has changed states. The lookup table starts with 4 bits indicating the next state transitions from 00, where 0 represents an illegal state switch, 1 represents clockwise increase, and -1 represents counterclockwise decrease. The following 4 bits indicate the next state transitions for 01, then 10, and ending with 11. The indexing of the lookup table relies on the previous state shifted left two bits and the current state in the two least significant bits. The values from the lookup table are then added to the encoder count and the previous state gets the current state.

The interrupt for the timer fires every millisecond and once it counts to 1000 ms (1 second), the count difference is calculated and used to calculate the revolutions per second. The count difference is divided by 1632 because the design is decoding the rising and falling edges of A and B (4 total), and since the motor has 408 pulses per rotation. The rps is printed out every second and the timer resets to begin sampling again.


### Hardware Implementation
The system hardware included connection to the EPP8266 and temperature sensor. The ESP8266 was directly placed into the MikroBUS socket on the development board while the temperature sensor was directly connected to the MCU pins. 

## Technical Documentation
The code for this lab can be found in this [Github repository](https://github.com/juliacygong/E155/tree/main/lab05). This contains the code for main.c file as well as external libraries used. 

### Schematic
The schematic below depicts the connections between the MCU and the motor. 

![Figure 1: The image shows the schematic of the digital audio hardware system.](images/lab5_schematic.png)

The flow chart below shows how interrupts are handled in the system.
![Figure 2: The image shows the flow chart for the interrupts.](images/flowchart.png)


## Results and Discussion
The system was able to correctly calculate the angular velocity of the motor in both the clockwise and counter clockwise directions. When the supply voltage was 10V, the print in the debugger read around +- 2 rev/s (depending on the direction). Additionally, the ancular velocity increased and decreased in respones to voltage supplied to the motor and read 0 when the power supply was off. 

### Oscilloscope Interrupt Pin Toggling

In order to observe the tradeoffs between using interrupts and polling to measure the angular velocity, I wrote some code for polling so I can toggle a pin for both to compare the toggling frequency for interrupts and polling.

The oscilloscope trace for interrupts shows a frequency of 2.4kHz, indicating the speed in which the interrupts are occurring. This means that for the polling to be able to sample all the encoder state changes, it must be sampling at least 4.8kHz (two times the frequency of the interrupts) to sample all the state changes and avoid aliasing. 
![Figure 3: This image shows the oscilloscope trace for interrupts.](images/itrace.JPG)

The oscilloscope trace for the polling shows are frequency of 2.20kHz as well as some breaks in the squre waves. This is likely because the system is polling too slowly to detect all the state changes.
![Figure 4: This image shows the oscilloscope trace polling.](images/pscope.JPG)

## Conclusion
I was able to design a system using interrupts to calculate the angular velocity of a motor using the rising and falling edges of the encoders!
This lab took a total of 8 hours. 

## AI Prototype Summary
For my AI prototype, I prompted ChatGPT with: Write me interrupt handlers to interface with a quadrature encoder. Iâ€™m using the STM32L432KC, what pins should I connect the encoder to in order to allow it to easily trigger the interrupts?

ChatGPT responded with the correct pins that can be used to connect the encoder to trigger interrupts, howevever, the interrupt handlers did not run. ChatGPT suggested that I use the TIM encoder mode and to not use EXTI/GPIO interrupts unless they were necessary. I found this interesting since I was using EXTI interrupts in this lab and thought that they did they job well. 
 